***Блинная сортировка***

Блинная сортировка — это алгоритм, использующий только операцию переворота префикса массива. В отличие от других методов, здесь нельзя менять местами отдельные элементы.

Синтаксис и операторы:

range(n, 1, -1) - цикл от конца массива к началу с шагом -1

max(arr[:curr_size]) - находит максимальный элемент в срезе массива

arr.index() - возвращает индекс элемента

flip(arr, k) - пользовательская функция переворота

while left < k: - цикл с двумя счетчиками для переворота

arr[left], arr[k] = arr[k], arr[left] - множественное присваивание для обмена элементов

Принцип работы:

Цикл уменьшает размер неотсортированной части

Поиск максимума в текущем диапазоне

Два переворота: сначала до максимума, затем всего участка

Перемещение максимума в правильную позицию

Временная сложность (Big O):

Все случаи: O(n²)


***Блочная сортировка***

Блочная (корзинная) сортировка — это алгоритм, распределяющий элементы по корзинам в зависимости от их значений с последующей индивидуальной сортировкой каждой корзины.

Синтаксис и операторы:

buckets = [[] for _ in range(n)] - создание пустых корзин через list comprehension

max(arr) - нахождение максимального значения массива

min(n - 1, int(num * n / (max_val + 1))) - вычисление индекса корзины с ограничением

buckets[index].append(num) - добавление элемента в соответствующую корзину

insertion_sort(bucket) - вызов вспомогательной функции сортировки

result.extend(bucket) - объединение отсортированных корзин

Принцип работы:

Создаются n пустых корзин

Элементы распределяются по корзинам с помощью функции распределения

Каждая корзина сортируется отдельно (сортировкой вставками)

Отсортированные корзины объединяются в результирующий массив

Временная сложность (Big O): O(n + k) Объяснение: Алгоритм эффективен при равномерном распределении данных, где k - количество корзин. Распределение элементов занимает O(n), а сортировка корзин в среднем O(k).


***Поиск скачками***

Поиск скачками — это алгоритм поиска в отсортированном массиве, который оптимизирует линейный поиск за счет "прыжков" через блоки элементов.

Синтаксис и операторы:

import math - импорт математического модуля

math.sqrt(n) - вычисление квадратного корня для определения размера прыжка

min(step, n) - 1 - ограничение индекса в пределах массива

while prev < n and arr[min(step, n) - 1] < target: - цикл прыжков с проверкой границ

for i in range(prev, min(step, n)): - линейный поиск в найденном блоке

Принцип работы:

Определяется оптимальный размер прыжка как √n

Алгоритм прыгает через блоки, пока не найдет блок с возможным целевым элементом

В найденном блоке выполняется линейный поиск целевого элемента

Временная сложность (Big O): O(√n) Объяснение: Алгоритм совершает O(√n) прыжков и выполняет O(√n) сравнений в последнем блоке, что делает его эффективнее линейного поиска для больших отсортированных массивов.

Особенности: Каждый элемент требует до O(n) операций переворота. Алгоритм использует только одну операцию, но неэффективен из-за квадратичной сложности и частых переворотов массива.


***Сортировка бусинами***

Сортировка бусинами (гравитационная) — это уникальный алгоритм, моделирующий естественное падение бусин под действием гравитации. Он работает только с неотрицательными целыми числами.

Синтаксис и операторы:

max(arr) - находит максимальное значение

[[0] * len(arr) for _ in range(max_val)] - создает 2D матрицу нулей через list comprehension

Вложенные циклы for i, num in enumerate(arr): и for j in range(num): для размещения бусин

beads[j][i] = 1 - оператор присваивания для установки бусины

sum(beads[i]) - подсчет бусин в строке через суммирование

Двойной цикл for j in range(len(arr)): и for i in range(max_val): для считывания результата

Принцип работы:

Создается матрица beads размером max_val × len(arr)

Расставляются единицы в соответствии со значениями массива

Бусины "падают" - перераспределяются по столбцам

Результат формируется подсчетом единиц в каждом столбце

Временная сложность (Big O):

Теоретически: O(n)

Практически: O(S) где S - сумма всех элементов

Особенности: Использует матричные операции и требует O(n × m) памяти. Эффективен только для небольших целых чисел.


***Тернарный поиск***

Тернарный поиск — это алгоритм поиска, который делит отсортированный массив на три равные части вместо двух, как в бинарном поиске.

Синтаксис и операторы:

mid1 = left + (right - left) // 3 - вычисление первой точки деления

mid2 = right - (right - left) // 3 - вычисление второй точки деления

Рекурсивные вызовы ternary_search_recursive() для трех возможных интервалов

if target < arr[mid1]:, elif target > arr[mid2]:, else: - проверка трех областей

Принцип работы:

Диапазон поиска делится на три равные части

Сравнивается целевой элемент с значениями в точках деления

В зависимости от результатов поиск продолжается в одной из трех частей

Процесс повторяется рекурсивно до нахождения элемента

Временная сложность (Big O): O(log₃n) Объяснение: На каждом шаге алгоритм уменьшает область поиска в 3 раза, что дает логарифмическую сложность с основанием 3, однако требует больше сравнений на каждой итерации по сравнению с бинарным поиском.


***Экспоненциальный поиск***

Экспоненциальный поиск — это алгоритм для быстрого поиска в отсортированных массивах, сочетающий экспоненциальное расширение диапазона с бинарным поиском.

Синтаксис и операторы:

while i < n and arr[i] <= target: - цикл экспоненциального увеличения диапазона

i *= 2 - удвоение размера диапазона на каждом шаге

binary_search(arr, target, i // 2, min(i, n - 1)) - вызов бинарного поиска в найденном диапазоне

mid = left + (right - left) // 2 - безопасное вычисление середины для избежания переполнения

Принцип работы:

Проверяется первый элемент массива

Диапазон поиска экспоненциально расширяется (1, 2, 4, 8...)

Когда найден диапазон, содержащий целевой элемент, применяется бинарный поиск

Временная сложность (Big O): O(log n) Объяснение: Экспоненциальное расширение занимает O(log n) шагов, и бинарный поиск в найденном диапазоне также O(log n), что сохраняет логарифмическую сложность даже для очень больших массивов.

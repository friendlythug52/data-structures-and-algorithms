**Задание 20. Имитация отжига для задачи размещения центров**

Условие. Разместить k центров на плоскости так, чтобы минимизировать суммарное 
расстояние от каждой из n точек‑клиентов до ближайшего центра.
Алгоритм: имитация отжига: случайное смещение центров, принятие решения по критерию 
Метрополиса.

**Язык примера: C++**

vector<pair<double, double>> sa_facility_location(
 const vector<pair<double, double>>& clients,
 int k, double temp, double cooling
) {

 // Инициализация: случайные позиции k центров
 
 vector<pair<double, double>> centers(k);
 for (int i = 0; i < k; i++) {
 centers[i] = {
 random_double(-10, 10),
 random_double(-10, 10)
 };
 }
 double current_cost = totalDistance(clients, centers);
 while (temp > 1e-6) {
 // Создаём кандидата: сдвигаем один случайный центр
 vector<pair<double, double>> new_centers = centers;
 int idx = random_int(0, k - 1);
 new_centers[idx].first += random_double(-1, 1) * temp;
 new_centers[idx].second += random_double(-1, 1) * temp;
 double new_cost = totalDistance(clients, new_centers);

 
 // ДОПИСАТЬ: принять/отклонить new_centers по критерию Метрополиса
 // Если принято, обновить centers и current_cost
 temp *= cooling;
 }
 return centers;
}


Что дописать:

1. Условие принятия нового решения:
o если new_cost < current_cost, принимаем;
o иначе принимаем с вероятностью exp((current_cost - new_cost)/temp).
2. Обновление centers и current_cost при принятии.
Примечания:
• Функция totalDistance считает сумму расстояний от каждого клиента до 
ближайшего центра.
• random_double(a, b) возвращает случайное число из [a,b].
• random_int(a, b) возвращает случайное целое из [a,b].



**анализ работы алгоритма по данному коду**
## Пошаговый анализ алгоритма имитации отжига для задачи размещения центров

### **Общая схема алгоритма:**

```
Ввод данных → Инициализация → Цикл отжига → Вывод результатов
```

---

## **ШАГ 1: Подготовка и ввод данных**

### **1.1. Ввод клиентов**
```cpp
vector<pair<double, double>> input_clients() {
    // Запрос количества клиентов
    // Построчный ввод координат (x, y) для каждого клиента
}
```
**Пример:**
```
Клиент 1: (0, 0)
Клиент 2: (1, 1) 
Клиент 3: (2, 2)
Клиент 4: (3, 3)
Клиент 5: (4, 4)
```

### **1.2. Ввод параметров алгоритма**
```cpp
void input_parameters(int& k, double& temp, double& cooling) {
    // k = количество центров
    // temp = начальная температура
    // cooling = коэффициент охлаждения
}
```
**Пример:**
```
k = 2, temp = 50, cooling = 0.95
```

---

## **ШАГ 2: Инициализация алгоритма**

### **2.1. Генерация случайных центров**
```cpp
vector<pair<double, double>> centers(k);
for (int i = 0; i < k; i++) {
    centers[i] = {random_double(-10, 10), random_double(-10, 10)};
}
```
**Действие:** Создаются k случайных центров в диапазоне [-10, 10]

**Пример результата:**
```
Центр 1: (3.2, -2.1)
Центр 2: (-1.5, 4.7)
```

### **2.2. Вычисление начальной стоимости**
```cpp
double current_cost = totalDistance(clients, centers);
```
**Алгоритм totalDistance:**
```
для каждого клиента:
    min_dist = ∞
    для каждого центра:
        dist = расстояние(клиент, центр)
        если dist < min_dist: min_dist = dist
    total += min_dist
```

**Пример вычисления:**
```
Клиент1: min(расст_до_Ц1, расст_до_Ц2) = 5.1
Клиент2: min(расст_до_Ц1, расст_до_Ц2) = 4.3
...
Сумма = current_cost = 25.7
```

---

## **ШАГ 3: Основной цикл отжига**

### **Цикл выполняется пока temp > 1e-6**

#### **3.1. Генерация нового решения-кандидата**
```cpp
vector<pair<double, double>> new_centers = centers;
int idx = random_int(0, k - 1);  // Выбираем случайный центр
new_centers[idx].first += random_double(-1, 1) * temp;
new_centers[idx].second += random_double(-1, 1) * temp;
```

**Особенности:**
- Изменяется только один случайный центр
- Размер смещения пропорционален температуре
- При высокой температуре: большие смещения (±50)
- При низкой температуре: маленькие смещения (±0.001)

**Пример:**
```
Температура: 50
Выбран центр 2
Смещение: (+0.7*50, -0.3*50) = (+35, -15)
Новая позиция: (-1.5+35, 4.7-15) = (33.5, -10.3)
```

#### **3.2. Вычисление новой стоимости**
```cpp
double new_cost = totalDistance(clients, new_centers);
```
**Пересчет расстояний для всех клиентов**

#### **3.3. Критерий Метрополиса**

**Случай A: Улучшение (new_cost < current_cost)**
```cpp
centers = new_centers;
current_cost = new_cost;
```
**Всегда принимаем улучшения**

**Случай B: Ухудшение (new_cost ≥ current_cost)**
```cpp
double acceptance_prob = exp((current_cost - new_cost) / temp);
if (random_double(0, 1) < acceptance_prob) {
    centers = new_centers;
    current_cost = new_cost;
}
```

**Пример расчета вероятности:**
```
current_cost = 25.7, new_cost = 27.2, temp = 50
ΔE = 25.7 - 27.2 = -1.5
P = exp(-1.5 / 50) = exp(-0.03) ≈ 0.97
```

**Вероятность принятия ухудшения = 97%**

#### **3.4. Охлаждение**
```cpp
temp *= cooling;  // temp = temp × 0.95
```

---

## **ШАГ 4: Динамика работы по фазам**

### **Фаза 1: Высокая температура (temp = 50-10)**
- **Смещения:** ±50 до ±10
- **Вероятность принятия ухудшений:** 30-80%
- **Поведение:** Активное исследование пространства
- **Цель:** Найти promising region

### **Фаза 2: Средняя температура (temp = 10-1)**
- **Смещения:** ±10 до ±1
- **Вероятность принятия ухудшений:** 10-30%
- **Поведение:** Баланс исследования/эксплуатации
- **Цель:** Уточнение хороших решений

### **Фаза 3: Низкая температура (temp = 1-1e-6)**
- **Смещения:** ±1 до ±0.000001
- **Вероятность принятия ухудшений:** <5%
- **Поведение:** Локальная оптимизация
- **Цель:** "Закаливание" решения

---

## **ШАГ 5: Завершение и вывод результатов**

### **5.1. Вычисление финальной стоимости**
```cpp
double final_cost = totalDistance(clients, result);
```

### **5.2. Анализ распределения клиентов**
```cpp
for каждого клиента:
    находим ближайший центр
    выводим расстояние до него
```

**Пример вывода:**
```
Центр 1: (2.1, 2.0)
Центр 2: (7.8, 8.1)

Клиент1 (0,0) -> Центр1 (расстояние: 2.9)
Клиент2 (1,1) -> Центр1 (расстояние: 1.4)
Клиент3 (9,9) -> Центр2 (расстояние: 1.7)
```

---

## **Ключевые особенности алгоритма**

### **1. Адаптивность смещений**
```cpp
// Размер шага зависит от температуры
shift = random_double(-1, 1) * temp
```
- **Начало:** Большие шаги для глобального поиска
- **Конец:** Малые шаги для тонкой настройки

### **2. Вероятностное принятие решений**
- Позволяет выходить из локальных минимумов
- Вероятность зависит от величины ухудшения и температуры

### **3. Постепенное "замораживание"**
- Температура уменьшается геометрически
- Алгоритм переходит от исследования к эксплуатации

### **4. Визуализация процесса**
```
Итерация 1: temp=50, cost=25.7  (исследование)
Итерация 50: temp=4.0, cost=18.2 (баланс)
Итерация 150: temp=0.1, cost=15.3 (уточнение)
Итерация 300: temp=0.0001, cost=15.1 (закаливание)
```

---

## **Преимущества подхода**

1. **Глобальная оптимизация** - избегает локальных минимумов
2. **Простота реализации** - понятные математические принципы
3. **Универсальность** - применим к различным задачам
4. **Робастность** - работает с разными начальными условиями

Алгоритм эффективно находит хорошие решения даже для сложных невыпуклых функций стоимости!




## **Оценка временной сложности**

Итоговая сложность: O(I × n × k)
Где:

I = количество итераций отжига = O(log(1/ε))

n = количество клиентов

k = количество центров

Обоснование:
Количество итераций I:

text
I = log(начальная_темп/конечная_темп) / log(1/cooling)
  = O(log(1/ε)) где ε = конечная температура
Самая дорогая операция на итерацию:

cpp
double new_cost = totalDistance(clients, new_centers);  // O(n × k)
Для каждого из n клиентов ищем ближайший из k центров

Выполняется на каждой итерации

Другие операции:

Генерация случайных чисел: O(1)

Критерий Метрополиса: O(1)

Обновление центров: O(1)

Практическая сложность:
text
T(n, k) ≈ 350 × n × k операций

Пример:
n = 1000, k = 10 → ~3.5 млн операций
n = 10000, k = 100 → ~350 млн операций
Доминирующая операция: многократный вызов totalDistance в основном цикле.



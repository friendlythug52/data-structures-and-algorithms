# Вариант 9. Жадный алгоритм для задачи о максимальном разрезе
Задача: реализовать жадный алгоритм для задачи о максимальном разрезе (MAX CUT).
Требования:
- Разделить вершины графа на две группы для максимизации ребер между группами
- Вывести две группы вершин и количество ребер в разрезе
Входные данные:
Граф с 8 вершинами (полный граф или граф с 15 ребрами)

# Определение
### Жадный алгоритм для задачи о максимальном разрезе графа
— это алгоритм, который на каждом шаге размещает вершину в ту группу, с которой у нее меньше связей, чтобы увеличить количество ребер между группами.

### Объяснение работы алгоритма:
- Создаются две пустые группы (group_a = set() и group_b = set())
- Формируется список вершин для обработки (vertices = list(graph.keys()))
- Для каждой вершины подсчитываются связи с группой A и группой B (connections_to_a и connections_to_b)
- Вершина помещается в группу с меньшим количеством связей
- Алгоритм возвращает полученные группы (return group_a, group_b)

### Временная сложность
Временная сложность — O(|V| + |E|).

**Почему**: внешний цикл выполняется |V| раз, а внутренний цикл по соседям в сумме дает |E| проверок, что в совокупности составляет O(|V| + |E|).

# Контрольные Вопросы №9
### Жадный алгоритм для покрытия множеств
Какой коэффициент аппроксимации имеет жадный алгоритм для задачи о покрытии множеств
и почему?

### Ответ
Жадный алгоритм для задачи о покрытии множеств имеет коэффициент аппроксимации H(n), где H(n) - n-ное гармоническое число, причем H(n) ≤ ln n + 1.

**Почему коэффициент аппроксимации H(n)**

- **Распределение стоимости**: При выборе каждого множества S его стоимость равномерно распределяется между новыми покрываемыми элементами
- **Порядок покрытия**: Элементы покрываются последовательно. Для элемента e, покрываемого на k-м шаге:
  - В момент покрытия оставалось не менее n/k непокрытых элементов
  - Оптимальное решение должно покрывать все эти элементы
  - Следовательно, оптимальное решение включает множество, покрывающее не менее n/k оставшихся элементов
- **Гармонические числа**: Суммарная стоимость алгоритма оценивается как ∑(1/k) для k=1..n = H(n) ≤ ln n + 1

**1 лабараторная**


Этот код показывает два способа реализации стека в Python. 
Первый использует стандартный список: методы append() и pop() работают как push и pop стека, обеспечивая поведение LIFO (последним пришел - первым ушел).
Второй подход реализует стек через связный список.
Класс Stack содержит указатель top на вершину. Метод push() создает новый узел и устанавливает его как новую вершину. Метод pop() удаляет верхний элемент, перемещая указатель на следующий узел.
Оба подхода обеспечивают основные операции стека, но реализация на связном списке более эффективна по времени, так как операции выполняются за O(1) без необходимости сдвигать элементы, как в списке.
Код демонстрирует принципы стека и разницу между простой и более оптимизированной реализацией.


**2 лабараторная**


Этот код демонстрирует работу с мультисписками (вложенными списками) в Python.
Сначала создается двумерный список 3x3, который выводится построчно. 
Затем добавляется новый подспиcок с помощью append(), увеличивая размер мультисписка.
Код показывает доступ к элементам по индексам [строка][столбец] и изменение значения конкретного элемента. 
Особенность Python позволяет создавать "зубчатые" массивы (jagged arrays), где подсписки имеют разную длину, что демонстрируется во втором примере.
Все операции выполняются с помощью базовых методов работы со списками, что делает мультисписки гибкой структурой для хранения табличных данных произвольной размерности. 
Вывод программы наглядно показывает каждое изменение структуры данных.


**3 лабараторная(куча фибоначчи)**

Фибоначчиева куча — это эффективная структура данных, реализованная через класс FibonacciHeap с внутренним классом Node. 
Каждый узел хранит ключ, значение и организован в циклический двусвязный список. 
Основные операции: insert (вставка за O(1)), find_min (поиск минимума за O(1)) и extract_min (извлечение минимума за O(log n) амортизированно).
При извлечении минимума происходит консолидация — объединение деревьев одинаковой степени через degree_table, что сохраняет структуру кучи.
Метод _link связывает узлы, делая один дочерним другому. 
Куча поддерживает минимум в min_node и эффективно управляет приоритетами, что полезно для алгоритмов вроде Дейкстры.
Пример использования демонстрирует вставку элементов (5"A", 3"B", 8"C", 1"D") и последовательное извлечение минимумов (1, 3, 5, 8).

** 3 лабараторная (хеш-таблицы)**

Данный код реализует хеш-таблицу с методом цепочек для разрешения коллизий. 
При инициализации создается массив из пустых списков-бакетов. 
Метод _hash вычисляет индекс через hash(key) % size. Put(key, value) находит бакет и либо обновляет значение при существующем ключе, либо добавляет новую пару. 
Get(key) выполняет линейный поиск в цепочке, remove(key) удаляет элемент, а contains проверяет наличие ключа через get. 
Все операции в среднем имеют сложность O(1), но в худшем случае при многих коллизиях достигают O(n). 
Структура эффективно хранит пары ключ-значение, автоматически обрабатывая коллизии путем добавления элементов в список соответствующего бакета.

** 3 лабараторная (бинарные кучи)**

Этот код реализует структуру данных "бинарная куча" (min-heap) с использованием встроенного модуля Python heapq. 
Класс BinaryHeap оборачивает функциональность модуля в удобный объектно-ориентированный интерфейс.

Основные методы:

push() добавляет элементы в кучу с сохранением её свойств

pop() извлекает минимальный элемент (корень)

peek() возвращает минимальный элемент без удаления

size() и is_empty() проверяют размер и пустоту

В примере использования числа [8, 3, 5, 1, 6, 2, 4, 7] добавляются в кучу. 
При извлечении они возвращаются в отсортированном порядке: 1 2 3 4 5 6 7 8. 
Это демонстрирует основное свойство мин-кучи - минимальный элемент всегда доступен за O(1), а операции добавления/удаления выполняются за O(log n). 
Код полезен для реализации приоритетных очередей и алгоритмов сортировки.


** 4 лабараторная(алгоритм дейкстры)**

Этот код реализует алгоритм Дейкстры для поиска кратчайшего пути между двумя точками в графе с неотрицательными весами. 
Алгоритм начинает из стартовой вершины, последовательно исследует все достижимые вершины, вычисляя минимальные расстояния до них, и использует приоритетную очередь для эффективного выбора следующей вершины для обработки.
В процессе работы он сохраняет информацию о предыдущих вершинах, что позволяет в конце восстановить не только длину кратчайшего пути, но и сам маршрут от начальной до конечной точки. 
Сложность: O((V + E) log V) благодаря приоритетной очереди, где каждая операция занимает O(log V). 
Алгоритм эффективно обрабатывает все вершины и рёбра графа, что делает его оптимальным для задач поиска кратчайших путей.

** 4 лабараторная (бинарное дерево)**

Это реализация бинарного дерева поиска (BST). Класс TreeNode представляет узел с значением и ссылками на левого/правого потомков.
Класс BinaryTree управляет деревом через корневой узел.

Основные операции:

insert() - вставка с сохранением свойств BST: O(h) времени, где h - высота дерева

search() - поиск элемента: O(h) времени

inorder_traversal() - обход в порядке "левый-корень-правый": O(n) времени и O(h) памяти (стек рекурсии)

find_path() - поиск пути к узлу: O(h) времени

Сложности в среднем случае: O(log n) для h-зависимых операций (сбалансированное дерево)
В худшем случае: O(n) (вырожденное дерево становится связным списком)

Код демонстрирует рекурсивные алгоритмы для работы с древовидной структурой данных, где эффективность зависит от сбалансированности дерева.


** 4 лабараторная (граф)**


Это реализация взвешенного неориентированного графа через список смежности. Класс Graph использует defaultdict(dict) для хранения вершин и взвешенных рёбер.

Сложности операций:

add_edge(u, v, weight): O(1) - добавление ребра в обе стороны

bfs(start): O(V + E) время, O(V) память - поиск в ширину с очередью

dfs(start): O(V + E) время, O(V) память - поиск в глубину с рекурсией

get_edges(): O(V + E) - получение всех уникальных рёбер

Ключевые особенности: BFS использует очередь для обхода уровня за уровнем, DFS рекурсивно углубляется, оба метода отслеживают посещённые вершины.
Граф неориентированный - рёбра добавляются в обе стороны. Код демонстрирует фундаментальные алгоритмы обхода графов для задач маршрутизации и анализа сетей.

**1 лабараторная**


Этот код показывает два способа реализации стека в Python. 
Первый использует стандартный список: методы append() и pop() работают как push и pop стека, обеспечивая поведение LIFO (последним пришел - первым ушел).
Второй подход реализует стек через связный список.
Класс Stack содержит указатель top на вершину. Метод push() создает новый узел и устанавливает его как новую вершину. Метод pop() удаляет верхний элемент, перемещая указатель на следующий узел.
Оба подхода обеспечивают основные операции стека, но реализация на связном списке более эффективна по времени, так как операции выполняются за O(1) без необходимости сдвигать элементы, как в списке.
Код демонстрирует принципы стека и разницу между простой и более оптимизированной реализацией.


**2 лабараторная**


Этот код демонстрирует работу с мультисписками (вложенными списками) в Python.
Сначала создается двумерный список 3x3, который выводится построчно. 
Затем добавляется новый подспиcок с помощью append(), увеличивая размер мультисписка.
Код показывает доступ к элементам по индексам [строка][столбец] и изменение значения конкретного элемента. 
Особенность Python позволяет создавать "зубчатые" массивы (jagged arrays), где подсписки имеют разную длину, что демонстрируется во втором примере.
Все операции выполняются с помощью базовых методов работы со списками, что делает мультисписки гибкой структурой для хранения табличных данных произвольной размерности. 
Вывод программы наглядно показывает каждое изменение структуры данных.


**3 лабараторная(куча фибоначчи)**

Фибоначчиева куча — это эффективная структура данных, реализованная через класс FibonacciHeap с внутренним классом Node. 
Каждый узел хранит ключ, значение и организован в циклический двусвязный список. 
Основные операции: insert (вставка за O(1)), find_min (поиск минимума за O(1)) и extract_min (извлечение минимума за O(log n) амортизированно).
При извлечении минимума происходит консолидация — объединение деревьев одинаковой степени через degree_table, что сохраняет структуру кучи.
Метод _link связывает узлы, делая один дочерним другому. 
Куча поддерживает минимум в min_node и эффективно управляет приоритетами, что полезно для алгоритмов вроде Дейкстры.
Пример использования демонстрирует вставку элементов (5"A", 3"B", 8"C", 1"D") и последовательное извлечение минимумов (1, 3, 5, 8).

**3 лабараторная (хеш-таблицы)**

Данный код реализует хеш-таблицу с методом цепочек для разрешения коллизий. 
При инициализации создается массив из пустых списков-бакетов. 
Метод _hash вычисляет индекс через hash(key) % size. Put(key, value) находит бакет и либо обновляет значение при существующем ключе, либо добавляет новую пару. 
Get(key) выполняет линейный поиск в цепочке, remove(key) удаляет элемент, а contains проверяет наличие ключа через get. 
Все операции в среднем имеют сложность O(1), но в худшем случае при многих коллизиях достигают O(n). 
Структура эффективно хранит пары ключ-значение, автоматически обрабатывая коллизии путем добавления элементов в список соответствующего бакета.

**3 лабараторная (бинарные кучи)**

Этот код реализует структуру данных "бинарная куча" (min-heap) с использованием встроенного модуля Python heapq. 
Класс BinaryHeap оборачивает функциональность модуля в удобный объектно-ориентированный интерфейс.

Основные методы:

push() добавляет элементы в кучу с сохранением её свойств

pop() извлекает минимальный элемент (корень)

peek() возвращает минимальный элемент без удаления

size() и is_empty() проверяют размер и пустоту

В примере использования числа [8, 3, 5, 1, 6, 2, 4, 7] добавляются в кучу. 
При извлечении они возвращаются в отсортированном порядке: 1 2 3 4 5 6 7 8. 
Это демонстрирует основное свойство мин-кучи - минимальный элемент всегда доступен за O(1), а операции добавления/удаления выполняются за O(log n). 
Код полезен для реализации приоритетных очередей и алгоритмов сортировки.


**4 лабараторная(алгоритм дейкстры)**

Этот код реализует алгоритм Дейкстры для поиска кратчайшего пути между двумя точками в графе с неотрицательными весами. 
Алгоритм начинает из стартовой вершины, последовательно исследует все достижимые вершины, вычисляя минимальные расстояния до них, и использует приоритетную очередь для эффективного выбора следующей вершины для обработки.
В процессе работы он сохраняет информацию о предыдущих вершинах, что позволяет в конце восстановить не только длину кратчайшего пути, но и сам маршрут от начальной до конечной точки. 
Сложность: O((V + E) log V) благодаря приоритетной очереди, где каждая операция занимает O(log V). 
Алгоритм эффективно обрабатывает все вершины и рёбра графа, что делает его оптимальным для задач поиска кратчайших путей.

**4 лабараторная (бинарное дерево)**

Это реализация бинарного дерева поиска (BST). Класс TreeNode представляет узел с значением и ссылками на левого/правого потомков.
Класс BinaryTree управляет деревом через корневой узел.

Основные операции:

insert() - вставка с сохранением свойств BST: O(h) времени, где h - высота дерева

search() - поиск элемента: O(h) времени

inorder_traversal() - обход в порядке "левый-корень-правый": O(n) времени и O(h) памяти (стек рекурсии)

find_path() - поиск пути к узлу: O(h) времени

Сложности в среднем случае: O(log n) для h-зависимых операций (сбалансированное дерево)
В худшем случае: O(n) (вырожденное дерево становится связным списком)

Код демонстрирует рекурсивные алгоритмы для работы с древовидной структурой данных, где эффективность зависит от сбалансированности дерева.


**4 лабараторная (граф)**


Это реализация взвешенного неориентированного графа через список смежности. Класс Graph использует defaultdict(dict) для хранения вершин и взвешенных рёбер.

Сложности операций:

add_edge(u, v, weight): O(1) - добавление ребра в обе стороны

bfs(start): O(V + E) время, O(V) память - поиск в ширину с очередью

dfs(start): O(V + E) время, O(V) память - поиск в глубину с рекурсией

get_edges(): O(V + E) - получение всех уникальных рёбер

Ключевые особенности: BFS использует очередь для обхода уровня за уровнем, DFS рекурсивно углубляется, оба метода отслеживают посещённые вершины.
Граф неориентированный - рёбра добавляются в обе стороны. Код демонстрирует фундаментальные алгоритмы обхода графов для задач маршрутизации и анализа сетей.


**5 лабараторная (Бинарный поиск)**

Алгоритм работает по принципу "разделяй и властвуй". На каждом шаге он сравнивает искомый элемент со средним элементом текущего диапазона поиска. Если значения равны — поиск завершен. Если искомый элемент больше среднего, поиск продолжается в правой половине массива, если меньше — в левой. Этот процесс повторяется до тех пор, пока элемент не будет найден или диапазон поиска не станет пустым.

Сложность алгоритма:

Временная сложность: O(log n)

Пространственная сложность: O(1)

Временная сложность O(log n) означает, что с каждым шагом алгоритм уменьшает область поиска вдвое. Для массива из 1000 элементов потребуется не более 10 итераций, для 1 000 000 элементов — не более 20 итераций. Это делает бинарный поиск чрезвычайно эффективным для больших отсортированных datasets по сравнению с линейным поиском O(n), который в худшем случае проверяет все элементы массива.

**5 лабараторная(Быстрая сортировка)**

Алгоритм работает по стратегии "разделяй и властвуй". Он выбирает опорный элемент (pivot) — в данном случае средний элемент массива — и разделяет массив на три части: элементы меньше опорного, равные ему и больше. Затем рекурсивно применяет ту же логику к левой и правой частям, пока не останутся подмассивы размером 0 или 1 элемент, которые уже считаются отсортированными.

Сложность алгоритма:

Средний случай: O(n log n)

Худший случай: O(n²)

Пространственная сложность: O(log n) - O(n)

Временная сложность O(n log n) в среднем случае делает быструю сортировку одним из самых эффективных алгоритмов сортировки. Худший случай O(n²) возникает при неудачном выборе опорного элемента (например, когда массив уже отсортирован, а pivot всегда выбирается как наименьший или наибольший элемент). Однако на практике Quick Sort часто outperforms другие алгоритмы благодаря своей эффективности и низкой скрытой константе в нотации Big O.


**5 лабараторная(Интерполяционный поиск)**

Алгоритм работает по стратегии "разделяй и властвуй". Он выбирает опорный элемент (pivot) — в данном случае средний элемент массива — и разделяет массив на три части: элементы меньше опорного, равные ему и больше. Затем рекурсивно применяет ту же логику к левой и правой частям, пока не останутся подмассивы размером 0 или 1 элемент, которые уже считаются отсортированными.

Сложность алгоритма:

Средний случай: O(n log n)

Худший случай: O(n²)

Пространственная сложность: O(log n) - O(n)

Временная сложность O(n log n) в среднем случае делает быструю сортировку одним из самых эффективных алгоритмов сортировки. Худший случай O(n²) возникает при неудачном выборе опорного элемента (например, когда массив уже отсортирован, а pivot всегда выбирается как наименьший или наибольший элемент). Однако на практике Quick Sort часто outperforms другие алгоритмы благодаря своей эффективности и низкой скрытой константе в нотации Big O.


**5 лабараторная(Линейный поиск)**

Алгоритм линейного поиска — базовый метод поиска, который последовательно проверяет каждый элемент массива. Он начинает с первого элемента и продолжает до тех пор, пока не найдет целевое значение или не достигнет конца массива.

Сложность алгоритма: Временная сложность — O(n) в худшем и среднем случае, когда элемент отсутствует или находится в конце. В лучшем случае (элемент первый) — O(1). Пространственная сложность — O(1), так как используется минимальная дополнительная память.

Преимущества: Простота реализации, универсальность работы с любыми типами данных, отсутствие требований к сортировке массива.

Алгоритм полезен для небольших массивов или когда данные неотсортированы. Для оптимизации поиска в больших наборах данных рекомендуются бинарный поиск (O(log n)) или хэш-таблицы (O(1)).

**5 лабараторная (Пирамидальная сортировка)**

Пирамидальная сортировка (Heap Sort) — это эффективный алгоритм сортировки, использующий структуру данных "двоичная куча". Алгоритм состоит из двух основных этапов: построение max-кучи и последовательное извлечение элементов.

Сложность алгоритма: Временная сложность — O(n log n) во всех случаях (худшем, среднем и лучшем). Пространственная сложность — O(1), так как сортировка выполняется на месте.

Принцип работы: Сначала массив преобразуется в max-кучу, где корневой элемент является наибольшим. Затем максимальный элемент перемещается в конец массива, и куча перестраивается для оставшихся элементов. Этот процесс повторяется пока весь массив не будет отсортирован.

Преимущества: Гарантированная производительность O(n log n), сортировка на месте без использования дополнительной памяти, устойчивая работа на больших объемах данных.

Алгоритм особенно полезен когда требуется гарантированное время выполнения и экономия памяти.

**5 лабараторная(Поиск Фибоначчи)**

Алгоритм поиска Фибоначчи — это эффективный метод поиска в отсортированном массиве, использующий числа Фибоначчи для определения позиций сравнения. Алгоритм основан на принципе деления массива на части в пропорциях золотого сечения.

Сложность алгоритма: O(log n) в худшем случае, что сравнимо с бинарным поиском. Пространственная сложность — O(1), так как используется только несколько переменных.

Принцип работы: Алгоритм использует числа Фибоначчи для определения диапазонов поиска. На каждом шаге он сравниет целевое значение с элементом в позиции, вычисленной через числа Фибоначчи. В зависимости от результата сравнения, область поиска сужается путем корректировки чисел Фибоначчи.

Преимущества: Эффективность сравнима с бинарным поиском, избегает дорогостоящих операций деления, используя только сложение и вычитание. Особенно эффективен на больших массивах и в системах, где деление является затратной операцией.

**5 лабараторная (Сортировка вставками)**

Алгоритм сортировки вставками — это простой и эффективный метод для небольших массивов или частично отсортированных данных. Принцип работы аналогичен тому, как человек сортирует карты в руке: каждый новый элемент помещается в правильную позицию среди уже упорядоченных элементов.

Сложность алгоритма: Лучший случай — O(n) для уже отсортированного массива, худший случай — O(n²) когда массив отсортирован в обратном порядке. Средний случай также O(n²). Пространственная сложность — O(1), так как сортировка выполняется на месте.

Принцип работы: Алгоритм последовательно берет каждый элемент, начиная со второго, и вставляет его в правильную позицию среди предыдущих уже отсортированных элементов, сдвигая большие элементы вправо.

Преимущества: Простота реализации, эффективность на небольших массивах, стабильность (сохраняет порядок равных элементов), адаптивность (быстро работает на частично отсортированных данных).

**5 лабараторная(Сортировка выбором)**

Алгоритм сортировки выбором — это простой метод сортировки, который последовательно находит минимальный элемент из неотсортированной части массива и помещает его в начало. Алгоритм разделяет массив на две части: отсортированную (слева) и неотсортированную (справа).

Сложность алгоритма: Временная сложность — O(n²) во всех случаях (лучшем, среднем и худшем), так как алгоритм всегда выполняет примерно n²/2 сравнений. Пространственная сложность — O(1), так как сортировка выполняется на месте.

Принцип работы: На каждой итерации алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом неотсортированной части. Таким образом, отсортированная часть увеличивается на один элемент после каждой итерации.

Преимущества: Простота реализации, минимальное количество перестановок (ровно n-1), что может быть полезно когда стоимость перестановки элементов высока.

**5 лабараторная (Сортировка пузырьком)**
Алгоритм сортировки пузырьком — это простой метод сортировки, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Этот процесс продолжается до тех пор, пока массив не будет полностью отсортирован.

Сложность алгоритма: Временная сложность — O(n²) в худшем и среднем случае, когда массив отсортирован в обратном порядке. В лучшем случае (уже отсортированный массив) — O(n). Пространственная сложность — O(1), так как сортировка выполняется на месте.

Принцип работы: На каждом проходе алгоритм последовательно сравнивает пары соседних элементов. Если они расположены в неправильном порядке, происходит их обмен. После каждого полного прохода наибольший "всплывающий" элемент занимает свою конечную позицию в конце массива.

Преимущества: Простота реализации и понимания, стабильность алгоритма, эффективность на почти отсортированных массивах.

**5 лабараторная (Сортировка слиянием)**

Алгоритм сортировки слиянием — это эффективный алгоритм, работающий по принципу "разделяй и властвуй". Он рекурсивно разделяет массив на две половины до тех пор, пока не останутся подмассивы из одного элемента, а затем объединяет их в упорядоченном порядке.

Сложность алгоритма: Временная сложность — O(n log n) во всех случаях (худшем, среднем и лучшем). Пространственная сложность — O(n), так как требуется дополнительная память для временных подмассивов.

Принцип работы: Алгоритм состоит из двух этапов: разделение исходного массива на меньшие подмассивы и слияние отсортированных подмассивов в один упорядоченный массив. Функция merge сравнивает элементы двух отсортированных массивов и последовательно добавляет меньший элемент в результирующий массив.

Преимущества: Стабильная сортировка, гарантированная производительность O(n log n), эффективная работа с большими наборами данных и связными списками.
